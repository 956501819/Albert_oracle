-- 写在前面
--作者：刘悦 (Albert)
/*
当我们普遍使用 触发器时，会发现这很严重的影响我们oracle数据库的性能，因此，我们可以在一些 对及时性要求非常高的数据表上面使用触发器，但是切记，不要使用过度了！！
当我们在一些实时性要求不高的oracle表的进行数据同步时，可以使用它的替换方案，个人建议用 merge 来进行
merge 的优点是速度较快，适合批量的，对数据实时性要求不高的数据处理，测试了下，在机器配置为内存4G 2核的linux 服务器上 同步3万条记录 用时15秒，每条记录，大概20多个字段
因此，merge 与oracle 定时任务的结合比较常见
*/

-- merg的 语法很简单

merge into table1    t1
using table2         t2
on (t1.字段1=t2.字段2)
when matched then  -- 当匹配是如何处理
  --处理方式一
when not matched then  -- 当不匹配是如何处理
   --处理方式二  


-- 在这里举一个现实的例子,注意下面建表语句where条件 1=2，意思是只是拷贝了一张表的结构

create table T_HOTSPOT_20190711 as
        select ID,T_GENE_MAN,SOURCE_ENGLISH,SOURCE_CHINESE,CHROM,POS,ALT,REF,ASSEMBLY_VERSION,NUCLEOTIDE_CHANGE,AMINO_ACID_CHANGE_ABB,AMINO_ACID_CHANGE,SITE_ANALYSIS_CHINESE,CARCINOMAS_YB,CARCINOMAS_OTHER,CLINICAL_TRIAL_HY,PHASE_CLINICAL_TRIAL,APPROVAL_OF_INDICATIONS,NCCN_GUIDE,ANALYSIS,CASE_REPORT,PRECLINICAL_EVIDENCE,POTENTIAL_BENEFITS,POTENTIAL_RESISTANCE,SITE_CLASSIFICATION,AUXILIARY_JUDGMENT,RISK_ASSESSMENT,TREATMENT_EVALUATION,PROGNOSIS_AFTER,CLASSIFICATION,NOTE1,NOTE2,MOLECULAR_FUNCTION,FDA_CFDA,FDA_CFDNA,PHASE,POTENTIAL_RESISTANCE_DRUGS,FDA_APPROVED,NCCN,CLINICAL_TRIALS,CASE_REPORTS,PRECLINICAL,SENSITIVITY,RESISTANCE,TIER,AUXILIARY_DIAGNOSIS,RECURRENT_RISK,TREATMENT,PROGNOSIS,MOLECULAR_CLASSIFICATION,TIP1,TIP2,UPDATE_USER,UPDATE_DATE
        from T_HOTSPOT where 1=2  

select count(1) from T_HOTSPOT_20190711  -- merge 前 0 条数据


-- 开始编写 merge 语句
/*
	注意事项，1.update的时候，不能为 表之间的关联字段
	          2.注意逗号，最后一个字段不要加逗号
*/




merge into T_HOTSPOT_20190711      t1
using  T_HOTSPOT                   t2
on (t1.id=t2.id)
when matched then
  update set
         t1.T_GENE_MAN=t2.T_GENE_MAN,
          t1.SOURCE_ENGLISH=t2.SOURCE_ENGLISH,
          t1.SOURCE_CHINESE=t2.SOURCE_CHINESE,
          t1.CHROM=t2.CHROM,
          t1.POS=t2.POS,
          t1.ALT=t2.ALT,
          t1.REF=t2.REF,
          t1.ASSEMBLY_VERSION=t2.ASSEMBLY_VERSION,
          t1.NUCLEOTIDE_CHANGE=t2.NUCLEOTIDE_CHANGE,
          t1.AMINO_ACID_CHANGE_ABB=t2.AMINO_ACID_CHANGE_ABB,
          t1.AMINO_ACID_CHANGE=t2.AMINO_ACID_CHANGE,
          t1.SITE_ANALYSIS_CHINESE=t2.SITE_ANALYSIS_CHINESE,
          t1.CARCINOMAS_YB=t2.CARCINOMAS_YB,
          t1.CARCINOMAS_OTHER=t2.CARCINOMAS_OTHER,
          t1.CLINICAL_TRIAL_HY=t2.CLINICAL_TRIAL_HY,
          t1.PHASE_CLINICAL_TRIAL=t2.PHASE_CLINICAL_TRIAL,
          t1.APPROVAL_OF_INDICATIONS=t2.APPROVAL_OF_INDICATIONS,
          t1.NCCN_GUIDE=t2.NCCN_GUIDE,
          t1.ANALYSIS=t2.ANALYSIS,
          t1.CASE_REPORT=t2.CASE_REPORT,
          t1.PRECLINICAL_EVIDENCE=t2.PRECLINICAL_EVIDENCE,
          t1.POTENTIAL_BENEFITS=t2.POTENTIAL_BENEFITS,
          t1.POTENTIAL_RESISTANCE=t2.POTENTIAL_RESISTANCE,
          t1.SITE_CLASSIFICATION=t2.SITE_CLASSIFICATION,
          t1.AUXILIARY_JUDGMENT=t2.AUXILIARY_JUDGMENT,
          t1.RISK_ASSESSMENT=t2.RISK_ASSESSMENT,
          t1.TREATMENT_EVALUATION=t2.TREATMENT_EVALUATION,
          t1.PROGNOSIS_AFTER=t2.PROGNOSIS_AFTER,
          t1.CLASSIFICATION=t2.CLASSIFICATION,
          t1.NOTE1=t2.NOTE1,
          t1.NOTE2=t2.NOTE2,
          t1.MOLECULAR_FUNCTION=t2.MOLECULAR_FUNCTION,
          t1.FDA_CFDA=t2.FDA_CFDA,
          t1.FDA_CFDNA=t2.FDA_CFDNA,
          t1.PHASE=t2.PHASE,
          t1.POTENTIAL_RESISTANCE_DRUGS=t2.POTENTIAL_RESISTANCE_DRUGS,
          t1.FDA_APPROVED=t2.FDA_APPROVED,
          t1.NCCN=t2.NCCN,
          t1.CLINICAL_TRIALS=t2.CLINICAL_TRIALS,
          t1.CASE_REPORTS=t2.CASE_REPORTS,
          t1.PRECLINICAL=t2.PRECLINICAL,
          t1.SENSITIVITY=t2.SENSITIVITY,
          t1.RESISTANCE=t2.RESISTANCE,
          t1.TIER=t2.TIER,
          t1.AUXILIARY_DIAGNOSIS=t2.AUXILIARY_DIAGNOSIS,
          t1.RECURRENT_RISK=t2.RECURRENT_RISK,
          t1.TREATMENT=t2.TREATMENT,
          t1.PROGNOSIS=t2.PROGNOSIS,
          t1.MOLECULAR_CLASSIFICATION=t2.MOLECULAR_CLASSIFICATION,
          t1.TIP1=t2.TIP1,
          t1.TIP2=t2.TIP2,
          t1.UPDATE_USER=t2.UPDATE_USER,
          t1.UPDATE_DATE=t2.UPDATE_DATE
when not matched then
     insert(ID,T_GENE_MAN,SOURCE_ENGLISH,SOURCE_CHINESE,CHROM,POS,ALT,REF,ASSEMBLY_VERSION,NUCLEOTIDE_CHANGE,AMINO_ACID_CHANGE_ABB,AMINO_ACID_CHANGE,SITE_ANALYSIS_CHINESE,CARCINOMAS_YB,CARCINOMAS_OTHER,CLINICAL_TRIAL_HY,PHASE_CLINICAL_TRIAL,APPROVAL_OF_INDICATIONS,NCCN_GUIDE,ANALYSIS,CASE_REPORT,PRECLINICAL_EVIDENCE,POTENTIAL_BENEFITS,POTENTIAL_RESISTANCE,SITE_CLASSIFICATION,AUXILIARY_JUDGMENT,RISK_ASSESSMENT,TREATMENT_EVALUATION,PROGNOSIS_AFTER,CLASSIFICATION,NOTE1,NOTE2,MOLECULAR_FUNCTION,FDA_CFDA,FDA_CFDNA,PHASE,POTENTIAL_RESISTANCE_DRUGS,FDA_APPROVED,NCCN,CLINICAL_TRIALS,CASE_REPORTS,PRECLINICAL,SENSITIVITY,RESISTANCE,TIER,AUXILIARY_DIAGNOSIS,RECURRENT_RISK,TREATMENT,PROGNOSIS,MOLECULAR_CLASSIFICATION,TIP1,TIP2,UPDATE_USER,UPDATE_DATE) values(t2.id,t2.T_GENE_MAN,t2.SOURCE_ENGLISH,t2.SOURCE_CHINESE,t2.CHROM,t2.POS,t2.ALT,t2.REF,t2.ASSEMBLY_VERSION,t2.NUCLEOTIDE_CHANGE,t2.AMINO_ACID_CHANGE_ABB,t2.AMINO_ACID_CHANGE,t2.SITE_ANALYSIS_CHINESE,t2.CARCINOMAS_YB,t2.CARCINOMAS_OTHER,t2.CLINICAL_TRIAL_HY,t2.PHASE_CLINICAL_TRIAL,t2.APPROVAL_OF_INDICATIONS,t2.NCCN_GUIDE,t2.ANALYSIS,t2.CASE_REPORT,t2.PRECLINICAL_EVIDENCE,t2.POTENTIAL_BENEFITS,t2.POTENTIAL_RESISTANCE,t2.SITE_CLASSIFICATION,t2.AUXILIARY_JUDGMENT,t2.RISK_ASSESSMENT,t2.TREATMENT_EVALUATION,t2.PROGNOSIS_AFTER,t2.CLASSIFICATION,t2.NOTE1,t2.NOTE2,t2.MOLECULAR_FUNCTION,t2.FDA_CFDA,t2.FDA_CFDNA,t2.PHASE,t2.POTENTIAL_RESISTANCE_DRUGS,t2.FDA_APPROVED,t2.NCCN,t2.CLINICAL_TRIALS,t2.CASE_REPORTS,t2.PRECLINICAL,t2.SENSITIVITY,t2.RESISTANCE,t2.TIER,t2.AUXILIARY_DIAGNOSIS,t2.RECURRENT_RISK,t2.TREATMENT,t2.PROGNOSIS,t2.MOLECULAR_CLASSIFICATION,t2.TIP1,t2.TIP2,t2.UPDATE_USER,t2.UPDATE_DATE)

select count(2) from T_HOTSPOT_20190711  -- merge 后 2567 条数据


-- *********************   看到得写这么长是不是头都大了？ 因为这里更新的是全部字段，你可以根据自己的需求选择 需要更新的字段
-- 如果必须更新全部字段呢？？   ，这里还有一个好方法可以帮助大家偷懒：用熟悉的一面编程语言来玩字符串分隔小游戏吧!  （我这里用python 来举例）
具体文件 看看本目录下面另一个python文件，给大家准备好了


-- :PS  当merge +dblink 相结合时 ，是不是就可以跨数据库进行同步了呢？  --> yes~































